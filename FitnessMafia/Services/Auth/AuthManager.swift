//
//  AuthManager.swift
//  FitnessMafia
//
//  Created by Francisco Alderete on 18/09/2025.
//

import Foundation
import Supabase
import Combine
import RevenueCat

class AuthManager: ObservableObject {
    @Published var isAuthenticated = false
    @Published var currentUser: User?
    @Published var isLoading = false
    @Published var errorMessage: String?

    private let supabase = SupabaseConfig.shared.client
    private var cancellables = Set<AnyCancellable>()

    init() {
        // Check for existing session on app launch
        Task {
            await checkExistingSession()
        }

        // Listen for auth state changes
        Task {
            await setupAuthStateListener()
        }
    }

    private func checkExistingSession() async {
        do {
            _ = try await supabase.auth.session
            await MainActor.run {
                self.isAuthenticated = true
            }
            await loadUserProfile()
        } catch {
            // No existing session, that's fine
            print("No existing session found")
        }
    }

    private func setupAuthStateListener() async {
        let authStateChanges = supabase.auth.authStateChanges

        for await (event, _) in authStateChanges {
            await MainActor.run {
                switch event {
                case .signedIn:
                    self.isAuthenticated = true
                    self.errorMessage = nil
                    Task {
                        await self.loadUserProfile()
                    }
                case .signedOut:
                    self.isAuthenticated = false
                    self.currentUser = nil
                    self.errorMessage = nil
                case .tokenRefreshed:
                    // Session refreshed, no action needed
                    break
                case .userUpdated:
                    // User updated, reload profile
                    Task {
                        await self.loadUserProfile()
                    }
                case .passwordRecovery:
                    // Handle password recovery if needed
                    break
                default:
                    // Handle any future auth events
                    break
                }
            }
        }
    }

    func signUp(email: String, password: String, username: String, firstName: String, lastName: String) async throws {
        await MainActor.run {
            self.isLoading = true
            self.errorMessage = nil
        }

        do {
            // Sign up with Supabase Auth (will send confirmation email)
            _ = try await supabase.auth.signUp(
                email: email,
                password: password
            )

            // Do NOT create the profile yet. The user must confirm email and sign in.
            // Profile will be created on first verified login in loadUserProfile().

            await MainActor.run {
                self.isLoading = false
            }

        } catch {
            await MainActor.run {
                self.isLoading = false
                self.errorMessage = getErrorMessage(from: error)
            }
            throw error
        }
    }

    func signIn(email: String, password: String) async throws {
        await MainActor.run {
            self.isLoading = true
            self.errorMessage = nil
        }

        do {
            try await supabase.auth.signIn(
                email: email,
                password: password
            )

            await MainActor.run {
                self.isLoading = false
            }

            // User profile will be loaded via auth state change listener

        } catch {
            await MainActor.run {
                self.isLoading = false
                self.errorMessage = getErrorMessage(from: error)
            }
            throw error
        }
    }

    func signOut() async throws {
        await MainActor.run {
            self.isLoading = true
            self.errorMessage = nil
        }

        do {
            try await supabase.auth.signOut()
            await MainActor.run {
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                self.isLoading = false
                self.errorMessage = getErrorMessage(from: error)
            }
            throw error
        }
    }

    private func createUserProfile(email: String, username: String, firstName: String, lastName: String) async throws {
        // Use auth user's id to satisfy FK users.app_user_id ‚Üí auth.users(id)
        let authAppUserId = supabase.auth.currentUser?.id.uuidString ?? UUID().uuidString

        let newUser = User(
            id: 0, // Will be auto-generated by the database
            appUserId: authAppUserId,
            username: username,
            email: email,
            role: .user,
            firstName: firstName,
            lastName: lastName,
            imageUrl: nil,
            isActive: true,
            isPremium: false,
            premiumExpiresAt: nil,
            premiumWillRenew: nil,
            createdAt: Date(),
            updatedAt: Date()
        )

        try await supabase
            .from("users")
            .insert(newUser)
            .execute()
    }

    func loadUserProfile() async {
        do {
            guard let authUser = supabase.auth.currentUser else { return }

            // Prefer lookup by app_user_id (FK to auth.users(id))
            let rows: [User] = try await supabase
                .from("users")
                .select()
                .eq("app_user_id", value: authUser.id.uuidString)
                .execute()
                .value

            if let existing = rows.first {
                await MainActor.run {
                    self.currentUser = existing
                    UserDefaults.standard.set(existing.appUserId, forKey: "app_user_id")
                }
                await loginUserToRevenueCat(userId: existing.appUserId)
                return
            }

            // If not found, create it and re-fetch
            let email = authUser.email ?? ""
            let baseUsername = email.split(separator: "@").first.map(String.init) ?? "usuario"
            try await createUserProfile(email: email, username: baseUsername, firstName: "", lastName: "")

            let created: User = try await supabase
                .from("users")
                .select()
                .eq("app_user_id", value: authUser.id.uuidString)
                .single()
                .execute()
                .value

            await MainActor.run {
                self.currentUser = created
                UserDefaults.standard.set(created.appUserId, forKey: "app_user_id")
            }
            await loginUserToRevenueCat(userId: created.appUserId)

        } catch {
            print("Error loading user profile: \(error)")
            await MainActor.run {
                self.errorMessage = getErrorMessage(from: error)
            }
        }
    }

    private func loginUserToRevenueCat(userId: String) async {
        do {
            let result = try await Purchases.shared.logIn(userId)
            print("‚úÖ User logged into RevenueCat: \(userId)")
            print("üìä Customer info updated, new user: \(result.created)")

            // The customer info is now tied to this UUID
            // Subscriptions will be shared across devices/platforms

        } catch {
            print("‚ùå Failed to log user into RevenueCat: \(error.localizedDescription)")
            // Continue without RevenueCat integration for this session
            // User can still use the app, just won't have subscription benefits
        }
    }

    private func getErrorMessage(from error: Error) -> String {
        let errorMessage = error.localizedDescription.lowercased()

        if errorMessage.contains("invalid") || errorMessage.contains("wrong") {
            return "Credenciales inv√°lidas. Verifica tu email y contrase√±a."
        } else if errorMessage.contains("already") || errorMessage.contains("exists") {
            return "Ya existe una cuenta con este email."
        } else if errorMessage.contains("not found") || errorMessage.contains("user") {
            return "No se encontr√≥ una cuenta con este email."
        } else if errorMessage.contains("confirm") || errorMessage.contains("email") {
            return "Por favor confirma tu email antes de iniciar sesi√≥n."
        } else {
            return "Error de autenticaci√≥n: \(error.localizedDescription)"
        }
    }
}
